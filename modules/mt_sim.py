#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
mr_lib: Matrix Algebra Formalism to analyze Magnetization Transfer Experiments.
"""

# ======================================================================
# :: Future Imports
from __future__ import division
from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals


# ======================================================================
# :: Python Standard Library Imports
# import os  # Miscellaneous operating system interfaces
# import shutil  # High-level file operations
# import math  # Mathematical functions
# import time  # Time access and conversions
# import datetime  # Basic date and time types
# import operator  # Standard operators as functions
# import collections  # High-performance container datatypes
# import argparse  # Parser for command-line options, arguments and subcommands

# import itertools  # Functions creating iterators for efficient looping
# import functools  # Higher-order functions and operations on callable objects
# import subprocess  # Subprocess management
# import multiprocessing  # Process-based parallelism
# import csv  # CSV File Reading and Writing [CSV: Comma-Separated Values]
# import json  # JSON encoder and decoder [JSON: JavaScript Object Notation]

# :: External Imports
import numpy as np  # NumPy (multidimensional numerical arrays library)
import scipy as sp  # SciPy (signal and image processing library)
# import matplotlib as mpl  # Matplotlib (2D/3D plotting library)
# import sympy as sym  # SymPy (symbolic CAS library)
# import PIL  # Python Image Library (image manipulation toolkit)
# import SimpleITK as sitk  # Image ToolKit Wrapper
# import nibabel as nib  # NiBabel (NeuroImaging I/O Library)
# import nipy  # NiPy (NeuroImaging in Python)
# import nipype  # NiPype (NiPy Pipelines and Interfaces)

# :: External Imports Submodules
# import matplotlib.pyplot as plt  # Matplotlib's pyplot: MATLAB-like syntax
# import mayavi.mlab as mlab  # Mayavi's mlab: MATLAB-like syntax
# import scipy.optimize  # SciPy: Optimization Algorithms
# import scipy.integrate  # SciPy: Numeric Integration Tools
# import scipy.constants  # SciPy: Mathematal and Physical Constants
# import scipy.ndimage  # SciPy: ND-image Manipulation
import scipy.linalg  # SciPy: Linear Algebra Tools

# :: Local Imports
# from mri_tools import VERB_LVL
# from mri_tools import D_VERB_LVL

# ======================================================================
def r_prod(*array_list):
    """
    Calculate the matrix right-product for a list of 2D arrays.
    """
    result = array_list[0]
    for array in array_list[1:]:
        result = np.dot(result, array)
    return result


# ======================================================================
def mdot_l(*array_list):
    """
    Calculate the matrix left-product for a list of 2D arrays.
    """
    result = array_list[-1]
    for array in array_list[-2::-1]:
        result = np.dot(array, result)
    return result


# ======================================================================
def dynamic_operator(physical_model):
    """

    """
    pass


# ======================================================================
def propagator_delay(
        dynamic_operator_arr,
        delay=0):
    """
    Calculate the propagator associated to delay.

    Parameters
    ----------
    dynamic_operator_arr: ndarray

    """
    delay *= 10e-3  # convert to s
    propagator = sp.linalg.expm(dynamic_operator_arr * delay)
    return propagator


# ======================================================================
def propagator_detection(
        physical_model_pools,
        phase=(np.pi / 2.0)):
    """
    Calculate the propagator associated to detection.

    Parameters
    ----------
    physical_model_pools: list

    TODO:
    """
    propagator = np.ones()
    return propagator


# ======================================================================
def propagator_spoil(
        physical_model_pools,
        scale=0):
    """
    Calculate the propagator associated to spoil.

    Parameters
    ----------
    operator_L_arr : ndarray
    TODO:

    """
    propagator = np.ones()
    return propagator


# ======================================================================
def propagator_pulse(
        physical_model,
        pulse,
        approximation='polynomial'):
    """
    Calculate the propagator associated to spoil.

    Parameters
    ----------
    physical_model : PhysicalModel
        Physical model used in the Magnetization Transfer experiment.
    pulse : Pulse
TODO:
    """
    propagator = np.ones()
    return propagator


# ======================================================================
def magnetization_transfer_signal(physical_model, pulse_sequence_params):
    """
    The magnetization transfer signal generated by the following sequence:

    RF  _()_/‾\____()_/\________________
    Gpe ___________/≣\____________
    Gsl ___________/≣\____________
    Gro ______________/‾‾‾‾‾‾‾‾\__
    ADC ______________/‾‾‾‾‾‾‾‾\__

    δx:     Delay
    σx:     Spoiler, _()_
    Pp:     Preparation (MT) pulse
    Ep:     Exc

    RF:     RadioFrequency signal
    Gpe:    Gradient for phase encoding
    Gsl:    Gradient for slice selection
    Gro:    Gradient for readout

    /|      inversion pulse
    /\      Gaussian pulse
    &       Sinc pulse
    |\      selective pulse
    TODO:
    """
    # mtloop=protocol parameter
    # meq := equilibrium magnetization
    dynamic_operator_arr = dynamic_operator(physical_model)
    propagator_spoil_arr = propagator_spoil(physical_model['pools'])
    propagator_detection_arr = propagator_detection(physical_model['pools'])
    propagator_delay1_arr, propagator_delay2_arr, propagator_delay3_arr = [
        propagator_delay(dynamic_operator_arr, pulse_sequence_params[key])
        for key in ['delay_1', 'delay_2', 'delay_3']]
    propagator_readout_arr, propagator_preparation_arr = [
        propagator_pulse(physical_model, pulse_sequence_params[key])
        for key in ['excitation_pulse', 'preparation_pulse']]

    # delay3 * readoutpulse * spoil * delay2 * mtpulse * spoil * delay1
    propagator_sequence = mdot_l(
            propagator_delay1_arr,
            propagator_spoil_arr,
            propagator_preparation_arr,
            propagator_delay2_arr,
            propagator_spoil_arr,
            propagator_readout_arr,
            propagator_delay3_arr)

    # detection * (sequence ^ num_loops) * equilibrium_magnetization
    signal = mdot_r(
            propagator_detection_arr,
            np.linalg.matrix_power(
                    propagator_sequence,
                    pulse_sequence['num_preparation_loops']),
            physical_model['equilibrium_magnetization'])
    return signal


# ======================================================================
if __name__ == '__main__':
    print(__doc__)
