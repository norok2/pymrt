#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PyMRT: generate numerical electro-magnetic fields
"""

# ======================================================================
# :: Future Imports
from __future__ import (
    division, absolute_import, print_function, unicode_literals, )

# ======================================================================
# :: Python Standard Library Imports
import os  # Miscellaneous operating system interfaces
# import shutil  # High-level file operations
import math  # Mathematical functions
# import time  # Time access and conversions
import datetime  # Basic date and time types
# import operator  # Standard operators as functions
# import collections  # Container datatypes
# import argparse  # Parser for command-line options, arguments and subcommands
import itertools  # Functions creating iterators for efficient looping
# import subprocess  # Subprocess management
# import multiprocessing  # Process-based parallelism
# import csv  # CSV File Reading and Writing [CSV: Comma-Separated Values]
# import json  # JSON encoder and decoder [JSON: JavaScript Object Notation]
import struct  # Interpret strings as packed binary data
import doctest  # Test interactive Python examples
import glob  # Unix style pathname pattern expansion
import warnings  # Warning control

# :: External Imports
import numpy as np  # NumPy (multidimensional numerical arrays library)
import scipy as sp  # SciPy (signal and image processing library)
# import matplotlib as mpl  # Matplotlib (2D/3D plotting library)
# import sympy as sym  # SymPy (symbolic CAS library)
# import PIL  # Python Image Library (image manipulation toolkit)
# import SimpleITK as sitk  # Image ToolKit Wrapper
# import nibabel as nib  # NiBabel (NeuroImaging I/O Library)
# import nipy  # NiPy (NeuroImaging in Python)
# import nipype  # NiPype (NiPy Pipelines and Interfaces)
import flyingcircus as fc

# :: External Imports Submodules
# import matplotlib.pyplot as plt  # Matplotlib's pyplot: MATLAB-like syntax
# import scipy.optimize  # SciPy: Optimization Algorithms
# import scipy.integrate  # SciPy: Integrations facilities
import scipy.constants  # SciPy: Mathematal and Physical Constants
import scipy.ndimage  # SciPy: ND-image Manipulation
import scipy.special  # SciPy: Special functions
import flyingcircus.util
import flyingcircus.num

# :: Local Imports
import pymrt as mrt
import pymrt.utils
import pymrt.geometry

from pymrt import INFO, PATH
from pymrt import VERB_LVL, D_VERB_LVL, VERB_LVL_NAMES
from pymrt import elapsed, report
from pymrt import msg, dbg


# ======================================================================
class CircularLoop(object):
    def __init__(
            self,
            center,
            normal,
            radius,
            current):
        """

        Args:
            center (Iterable[int|float]): The center of the loop in px.
                This can be a 2D or 3D vector.
            normal (Iterable[int|float]): The normal of the loop.
                This is a 2D or 3D unit vector.
            radius (int|float): The radius of the circle in px.
            current (int|float): The current circulating in the loop.
        """
        self.center = self._to_3d(np.array(center))
        self.normal = self._to_3d(np.array(normal) / np.linalg.norm(normal))
        self.radius = radius
        self.current = current

    # --------------------------------
    @staticmethod
    def _to_3d(vect, extra_dim=0):
        if vect.size == 2:
            vect_3d = np.zeros(3, dtype=vect.dtype)
            vect_3d[:2] = vect
            if extra_dim:
                vect_3d[2] = extra_dim
            return vect_3d
        elif vect.size == 3:
            return vect
        else:  # vect.size > 3 or vect.size < 2
            raise ValueError('Vector must be 2D or 3D')


# ======================================================================
def is_vector_field(shape):
    """
    Check if a given array qualifies as a vector field.

    Args:
        arr (np.ndarray): The input array.

    Returns:
        result (bool): True if `arr` can be a vector field, False otherwise.
    """
    return len(shape[:-1]) == shape[-1]


# ======================================================================
def b_circular_loop(
        shape,
        circ_loop,
        n_dim=3,
        rel_position=True):
    """
    Conpute the magnetic field generated by a single circular loop.

    For 2D inputs, the normal of the circular loop is assumed to be in the
    2D plane and the only the field in that plane is computed.

    Args:
        fov_arr (np.ndarray): The Field-Of-View (FOV) array.
        circ_loop (CircularLoop): The circular loop.

    Returns:
        b_arr (np.ndarray): The B 3D-vector field.
            The last dim contains the cartesian components of the field:
            B_x = b_arr[..., 0], B_y = b_arr[..., 1], etc.
            Even if the input is 2D, the result is always a 3D vector field
            (with the 3rd dim equal to 1).
            The 3D vector field is represented as a 4D array
            (with the 4th dim of size 3).

    References:
        - Bergeman, T., Gidon Erez, and Harold J. Metcalf. “Magnetostatic
          Trapping Fields for Neutral Atoms.” Physical Review A 35, no. 4
          (February 1, 1987): 1535–46.
          https://doi.org/10.1103/PhysRevA.35.1535.
        - Simpson, James C. Lane. “Simple Analytic Expressions for the
          Magnetic Field of a Circular Current Loop,” January 1,
          2001. https://ntrs.nasa.gov/search.jsp?R=20010038494.
    """
    # : extend 2D to 3D
    # check compatibility of given parameters
    shape = fc.util.auto_repeat(shape, n_dim, check=True)

    xx, yy, zz = fc.num.grid_coord(
        shape, circ_loop.center, is_relative=rel_position, use_int=False)
    xx, yy, zz = fc.num.rotate_3d_grid_coord(xx, yy, zz)
    # rr = np.sqrt(xx ** 2 + yy ** 2 + zz ** 2)  # inlined
    aa = circ_loop.radius
    cc = circ_loop.current * sp.constants.mu_0 / np.pi
    rho2 = (xx ** 2 + yy ** 2)
    ah2 = aa ** 2 + (xx ** 2 + yy ** 2 + zz ** 2) - 2 * aa * np.sqrt(rho2)
    bh2 = aa ** 2 + (xx ** 2 + yy ** 2 + zz ** 2) + 2 * aa * np.sqrt(rho2)
    ekk2 = sp.special.ellipe(1 - ah2 / bh2)
    kkk2 = sp.special.ellipkm1(ah2 / bh2)
    # gh = xx ** 2 - yy ** 2
    b_x = cc * xx * zz / (2 * ah2 * np.sqrt(bh2) * rho2) * (
            (aa ** 2 + (xx ** 2 + yy ** 2 + zz ** 2)) * ekk2 - ah2 * kkk2)
    b_y = cc * yy * zz / (2 * ah2 * np.sqrt(bh2) * rho2) * (
            (aa ** 2 + (xx ** 2 + yy ** 2 + zz ** 2)) * ekk2 - ah2 * kkk2)
    b_z = cc / (2 * ah2 * np.sqrt(bh2)) * (
            (aa ** 2 - (xx ** 2 + yy ** 2 + zz ** 2)) * ekk2 + ah2 * kkk2)
    return np.stack((b_x, b_y, b_z), -1)


# ======================================================================
def b_circular_loops(
        shape,
        circ_loops):
    """
    Conpute the magnetic field generated by a set of circular loops.

    Args:
        fov_arr (np.ndarray): The Field-Of-View (FOV) array.
        circ_loops (Iterable[CircularLoop]): The circular loop.

    Returns:
        b_arr (np.ndarray): The B 3D-vector field.
            The last dim contains the cartesian components of the field:
            B_x = b_arr[..., 0], B_y = b_arr[..., 1], etc.
            Even if the input is 2D, the result is always a 3D-vector field
            (with the 3rd dim of size 1).
            The 3D vector field is represented as a 4D array
            (with the 4th dim of size 3).
    """
    b_arr = np.zeros(tuple(fov_arr.shape) + (fov_arr.ndim,))
    for circ_loop in circ_loops:
        b_arr += b_circular_loop(fov_arr, circ_loop)
    return b_arr


# ======================================================================
def field_magnitude(
        arr,
        field_dims=3):
    """
    Compute the magnitude of the vector field.

    Args:
        arr:

    Returns:

    """
    assert (is_vector_field(arr.shape[:field_dims + 1]))
    return np.sqrt(np.sum(arr ** 2, axis=field_dims))


# ======================================================================
def field_phase(
        arr,
        axes=(0, 1)):
    """
    Compute the orthogonal phase of the vector field.

    This assumes that `arr` is 3D-vector field represented as a 4D array
    (with the 4th dim of size 3).

    Args:
        arr:

    Returns:

    """
    assert (is_vector_field(arr.shape[:4]))
    return np.arctan2(arr[:, :, :, axes[0], ...], arr[:, :, :, axes[1], ...])


b_arr = b_circular_loop(
    4, CircularLoop([0.5, 0.5, 0.5], [1, 1, 1], 1, 1)) * 1e6
print(b_arr[0, 0, 0])
print(field_magnitude(b_arr))

# ======================================================================
elapsed(__file__[len(PATH['base']) + 1:])

# ======================================================================
if __name__ == '__main__':
    import doctest  # Test interactive Python examples

    msg(__doc__.strip())
    doctest.testmod()
    msg(report())
