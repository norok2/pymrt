#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PyMRT: generate numerical electro-magnetic fields
"""

# ======================================================================
# :: Future Imports
from __future__ import (
    division, absolute_import, print_function, unicode_literals, )

# ======================================================================
# :: Python Standard Library Imports
# import os  # Miscellaneous operating system interfaces
# import shutil  # High-level file operations
# import math  # Mathematical functions
# import time  # Time access and conversions
# import datetime  # Basic date and time types
# import operator  # Standard operators as functions
# import collections  # Container datatypes
# import argparse  # Parser for command-line options, arguments and subcommands
# import itertools  # Functions creating iterators for efficient looping
# import subprocess  # Subprocess management
# import multiprocessing  # Process-based parallelism
# import csv  # CSV File Reading and Writing [CSV: Comma-Separated Values]
# import json  # JSON encoder and decoder [JSON: JavaScript Object Notation]
# import struct  # Interpret strings as packed binary data
# import doctest  # Test interactive Python examples
# import glob  # Unix style pathname pattern expansion
# import warnings  # Warning control

# :: External Imports
import numpy as np  # NumPy (multidimensional numerical arrays library)
import scipy as sp  # SciPy (signal and image processing library)
# import matplotlib as mpl  # Matplotlib (2D/3D plotting library)
# import sympy as sym  # SymPy (symbolic CAS library)
# import PIL  # Python Image Library (image manipulation toolkit)
# import SimpleITK as sitk  # Image ToolKit Wrapper
# import nibabel as nib  # NiBabel (NeuroImaging I/O Library)
# import nipy  # NiPy (NeuroImaging in Python)
# import nipype  # NiPype (NiPy Pipelines and Interfaces)
import flyingcircus as fc

# :: External Imports Submodules
# import matplotlib.pyplot as plt  # Matplotlib's pyplot: MATLAB-like syntax
# import scipy.optimize  # SciPy: Optimization Algorithms
# import scipy.integrate  # SciPy: Integrations facilities
import scipy.constants  # SciPy: Mathematal and Physical Constants
import scipy.ndimage  # SciPy: ND-image Manipulation
import scipy.special  # SciPy: Special functions
import flyingcircus.util
import flyingcircus.num

# :: Local Imports
import pymrt as mrt
import pymrt.utils
import pymrt.geometry

from pymrt import INFO, PATH
from pymrt import VERB_LVL, D_VERB_LVL, VERB_LVL_NAMES
from pymrt import elapsed, report
from pymrt import msg, dbg


# ======================================================================
class CircularLoop(object):
    def __init__(
            self,
            center,
            normal,
            radius,
            current):
        """

        Args:
            center (Iterable[int|float]): The center of the loop in px.
                This can be a 2D or 3D vector.
            normal (Iterable[int|float]): The normal of the loop.
                This is a 2D or 3D unit vector.
            radius (int|float): The radius of the circle in px.
            current (int|float): The current circulating in the loop.
        """
        self.center = self._to_3d(np.array(center))
        self.normal = self._to_3d(fc.num.normalize(normal))
        self.radius = radius
        self.current = current

    # --------------------------------
    @staticmethod
    def _to_3d(vect, extra_dim=0):
        if vect.size == 2:
            vect_3d = np.zeros(3, dtype=vect.dtype)
            vect_3d[:2] = vect
            if extra_dim:
                vect_3d[2] = extra_dim
            return vect_3d
        elif vect.size == 3:
            return vect
        else:  # vect.size > 3 or vect.size < 2
            raise ValueError('Vector must be 2D or 3D')


# ======================================================================
def is_vector_field(
        shape,
        index=0):
    """
    Check if a given array qualifies as a vector field.

    A N-dim array can be a vector field if for a given index, the number
    of dims is at least as the size of the array for that specific index.
    For example, a ND array can represent a 3D vector field if the dimension
    identified by has size at most N.

    Args:
        shape (Iterable[int]): The shape of the array.
        index (int): The dimension satisfying the vector field relationship.
            When the index is 0, this is consistent with `np.mgrid()`.

    Returns:
        result (bool): True if `arr` can be a vector field, False otherwise.
    """
    return len(shape[:index]) <= shape[index]


# ======================================================================
def b_circular_loop(
        shape,
        circ_loop,
        n_dim=3,
        rel_position=True):
    """
    Conpute the magnetic field generated by a single circular loop.

    For 2D inputs, the normal of the circular loop is assumed to be in the
    2D plane and the only the field in that plane is computed.

    Args:
        shape (int|Iterable[int]): The shape of the container in px.

        n_dim (int|None): The number of dimensions.
            If None, the number of dims is guessed from `shape`.
        circ_loop (CircularLoop): The circular loop.
        rel_position (bool): Interpret positions as relative values.
            If True, position values are interpreted as relative,
            i.e. they are scaled for `shape` using `fc.num.grid_coord()`.
            Otherwise, they are interpreted as absolute (in px).

    Returns:
        b_arr (np.ndarray): The B 3D-vector field.
            The first dim contains the cartesian components of the field:
            B_x = b_arr[0, ...], B_y = b_arr[1, ...], etc.
            Even if the input is 2D, the result is always a 3D vector field
            The 3D vector field is represented as a 4D array
            (with the 1st dim of size 3).

    References:
        - Bergeman, T., Gidon Erez, and Harold J. Metcalf. “Magnetostatic
          Trapping Fields for Neutral Atoms.” Physical Review A 35, no. 4
          (February 1, 1987): 1535–46.
          https://doi.org/10.1103/PhysRevA.35.1535.
        - Simpson, James C. Lane. “Simple Analytic Expressions for the
          Magnetic Field of a Circular Current Loop,” January 1,
          2001. https://ntrs.nasa.gov/search.jsp?R=20010038494.
    """
    # : extend 2D to 3D
    # check compatibility of given parameters
    shape = fc.util.auto_repeat(shape, n_dim, check=True)
    # : generate coordinates
    normal = np.array([0., 0., 1.])
    # : rotate coordinates ([0, 0, 1] is the standard loop normal)
    xx = fc.num.grid_coord(
        shape, circ_loop.center, is_relative=rel_position, use_int=False)
    rot_matrix = fc.num.rotation_3d_from_vectors(normal, circ_loop.normal)
    irot_matrix = fc.num.rotation_3d_from_vectors(circ_loop.normal, normal)
    if not np.all(normal == circ_loop.normal):
        xx = fc.num.grid_transform(xx, rot_matrix)
    # inline `rr2` for lower memory footprint (but execution will be slower)
    # todo: make sure that circ_loop honor `is_relative` directive
    rr2 = (xx[0] ** 2 + xx[1] ** 2 + xx[2] ** 2)
    aa = circ_loop.radius
    cc = circ_loop.current * sp.constants.mu_0 / np.pi
    rho2 = (xx[0] ** 2 + xx[1] ** 2)
    ah2 = aa ** 2 + rr2 - 2 * aa * np.sqrt(rho2)
    bh2 = aa ** 2 + rr2 + 2 * aa * np.sqrt(rho2)
    ekk2 = sp.special.ellipe(1 - ah2 / bh2)
    kkk2 = sp.special.ellipkm1(ah2 / bh2)
    # gh = xx[0] ** 2 - xx[1] ** 2  # not used for the field formulae
    b_x = cc * xx[0] * xx[2] / (2 * ah2 * np.sqrt(bh2) * rho2) * (
            (aa ** 2 + rr2) * ekk2 - ah2 * kkk2)
    b_y = cc * xx[1] * xx[2] / (2 * ah2 * np.sqrt(bh2) * rho2) * (
            (aa ** 2 + rr2) * ekk2 - ah2 * kkk2)
    b_z = cc / (2 * ah2 * np.sqrt(bh2)) * (
            (aa ** 2 - rr2) * ekk2 + ah2 * kkk2)
    b_arr = np.stack((b_x, b_y, b_z), 0)
    b_arr = fc.num.grid_transform(b_arr, irot_matrix)
    return b_arr


# ======================================================================
def b_circular_loops(
        shape,
        circ_loops):
    """
    Conpute the magnetic field generated by a set of circular loops.

    Args:
        fov_arr (np.ndarray): The Field-Of-View (FOV) array.
        circ_loops (Iterable[CircularLoop]): The circular loop.

    Returns:
        b_arr (np.ndarray): The B 3D-vector field.
            The last dim contains the cartesian components of the field:
            B_x = b_arr[..., 0], B_y = b_arr[..., 1], etc.
            Even if the input is 2D, the result is always a 3D-vector field
            (with the 3rd dim of size 1).
            The 3D vector field is represented as a 4D array
            (with the 4th dim of size 3).
    """
    b_arr = np.zeros(tuple(shape) + (len(shape),))
    for circ_loop in circ_loops:
        b_arr += b_circular_loop(shape, circ_loop)
    return b_arr


# ======================================================================
def field_magnitude(
        arr,
        index=0):
    """
    Compute the magnitude of the vector field.

    Args:
        arr (np.ndarray): The input vector field.
        index (int): The dimension satisfying the vector field relationship.
            When the index is 0, this is consistent with `np.mgrid()`.

    Returns:
        arr (np.ndarray): The vector field magnitude.
    """
    assert (is_vector_field(arr.shape))
    return np.sqrt(np.sum(arr ** 2, axis=index))


# ======================================================================
def field_phase(
        arr,
        index=0,
        axes=(0, 1)):
    """
    Compute the orthogonal phase of the vector field.

    This assumes that `arr` is 3D-vector field represented as a 4D array
    (with the 4th dim of size 3).

    Args:
        arr (np.ndarray): The input vector field.
        index (int): The dimension satisfying the vector field relationship.
            When the index is 0, this is consistent with `np.mgrid()`.
        axes (Iterable[int]): The vector field components to use.
            Only the first 2 values are used.

    Returns:
        arr (np.ndarray): The vector field phase for the specified axes.
    """
    assert (is_vector_field(arr.shape))
    masks = [
        tuple(
            slice(None) if i != index else axis
            for i, d in enumerate(arr.shape))
        for axis in axes]
    return np.arctan2(arr[masks[0]], arr[masks[1]])


# ======================================================================
def helmoltz_loops(
        shape,
        radius=0.4,
        distance=None,
        n_dim=3):
    raise NotImplementedError


# ======================================================================
def maxwell_loops(
        shape,
        radius=0.4,
        distances=None,
        n_dim=3):
    raise NotImplementedError


# ======================================================================
elapsed(__file__[len(PATH['base']) + 1:])

# ======================================================================
if __name__ == '__main__':
    import doctest  # Test interactive Python examples

    msg(__doc__.strip())
    doctest.testmod()
    msg(report())
